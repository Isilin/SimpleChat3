package server;import common.*;import java.io.IOException;import java.util.Observable;import java.util.Observer;import ocsf.server.*;/** * This class overrides some of the methods in the abstract  * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer implements Observer{  //Class variables *************************************************    /**   * The default port to listen on.   */  final public static int DEFAULT_PORT = 5555;    ChatIF serverUI;  ObservableOriginatorServer server;      //Constructors ****************************************************    /**   * Constructs an instance of the echo server.   *   * @param port The port number to connect on.   */  public EchoServer(int port, ChatIF console) throws IOException   {    this.server = new ObservableOriginatorServer(port);    this.server.addObserver(this);    this.serverUI = console;  }    //Instance methods ************************************************    public void listen() throws IOException  {	this.server.listen();    }    public void handleMessageFromServerUI(String message) throws IOException  {	  	String[] args = null;		try {			if(message.contains("#")) {				args = message.split(" ");				switch(args[0]) {					case "#quit":						this.server.sendToAllClients(message);						this.server.close();						this.serverUI.display("Server closed");						System.exit(0);						break;					case "#stop":						try{							this.server.stopListening();						} catch(Exception e){							System.err.println(e.getMessage());						}						break;					case "#close":						this.server.sendToAllClients(message);						this.server.close();						break;					case "#setport":						if(!this.server.isListening()) {							this.server.setPort(Integer.parseInt(args[1]));						} else {							this.serverUI.display("Please stop server before changing parameters !");						}						break;					case "#start":						if(!this.server.isListening()) {							try{								this.server.listen();							} catch(Exception e){								System.err.println(e.getMessage());							}						}						break;					case "#getport":						this.serverUI.display(Integer.toString(this.server.getPort()));						break;					default:						this.serverUI.display("Sorry, command not found !");						break;				}			} else {				this.server.sendToAllClients("[Server MSG] " + message);			}		} catch (Exception e) {			e.printStackTrace();		}  }    //Class methods ***************************************************    protected void clientConnected(ConnectionToClient client) {	  System.out.println(client + " connected.");  }  synchronized protected void clientDisconnected(    ConnectionToClient client) {	  System.out.println(client + " disconnected.");  }  synchronized protected void clientException(    ConnectionToClient client, Throwable exception) {	  System.out.println("A client has crashed : " + exception.getMessage());	  exception.printStackTrace();  }	@Override	public void update(Observable o, Object arg) {		// TODO Auto-generated method stub		OriginatorMessage msg = (OriginatorMessage) arg;		if(msg != null) {			String[] args = ((String)msg.getMessage()).split(" ");			switch(args[0]) {			  	case "#quit":					try {						msg.getOriginator().close();					} catch (IOException e) {						System.out.println("test");						e.printStackTrace();					}			  		break;			  	case "#logoff":					try {						msg.getOriginator().close();					} catch (IOException e) {						System.out.println("test");						e.printStackTrace();					}			  		break;			  	case "#login":			  		try {			  			msg.getOriginator().setInfo("name", args[1]);				  		this.server.sendToAllClients("Client "+ args[1] + " connected.");			  		}			  		catch (ArrayIndexOutOfBoundsException e) {			  			msg.getOriginator().setInfo("name", "Anonymous");				  		this.server.sendToAllClients("Client Anonymous connected.");			  		}			  		break;			  	default:			  		if(msg.getOriginator() != null) {						System.out.println("Message received: " + msg.getMessage() + " from " + msg.getOriginator());						this.server.sendToAllClients(msg.getOriginator().getInfo("name") + " : " + msg.getMessage());			  		}					break;			}		}	}}//End of EchoServer class