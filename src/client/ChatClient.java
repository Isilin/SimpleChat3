// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com package client;import ocsf.client.*;import common.*;import java.io.*;import java.util.Observable;import java.util.Observer;/** * This class overrides some of the methods defined in the abstract * superclass in order to give more functionality to the client. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave; * @author Fran&ccedil;ois B&eacute;langer * @version July 2000 */public class ChatClient implements Observer{  //Instance variables **********************************************    /**   * The interface type variable.  It allows the implementation of    * the display method in the client.   */  ChatIF clientUI;  ObservableSWRClient client;    private String id;    //Constructors ****************************************************    /**   * Constructs an instance of the chat client.   *   * @param host The server to connect to.   * @param port The port number to connect on.   * @param clientUI The interface type variable.   */    public ChatClient(String host, int port, ChatIF clientUI, String idIn)     throws IOException   {    this.client = new ObservableSWRClient(host, port);    this.client.addObserver(this);    this.clientUI = clientUI;    this.id = idIn;    try {		if(this.client.connectAndWait()){		    this.client.sendToServer("#login " + this.id);		}	} catch (Exception e) {		e.printStackTrace();	}  }    //Instance methods ************************************************  /**   * Hook method called after the connection has been closed.   * The default implementation does nothing. The method   * may be overriden by subclasses to perform special processing   * such as cleaning up and terminating, or attempting to   * reconnect.   */  protected void connectionClosed()   {	    }  /**   * Hook method called each time an exception is thrown by the   * client's thread that is reading messages from the server.   * The method may be overridden by subclasses.   * Most exceptions will cause the end of the reading thread except for   * <code>ClassNotFoundException<\code>s received when an object of   * unknown class is received and for the <code>RuntimeException</code>s   * that can be thrown by the message handling method implemented by the user.   *   * @param exception the exception raised.   */  protected void connectionException(Exception exception)   {	    }  /**   * Hook method called after a connection has been established.   * The default implementation does nothing.   * It may be overridden by subclasses to do anything they wish.   */  protected void connectionEstablished()   {	    }  /**   * Handles a message sent from the server to this client.   * This MUST be implemented by subclasses, who should respond to   * messages.   *   * @param msg   the message sent.   */  protected void handleMessageFromServer(String msg)  {	  switch(msg) {		  case "#quit":				this.quit();				break;		  case "#close":				try {					this.client.closeConnection();				} catch (IOException e) {					// TODO Auto-generated catch block					e.printStackTrace();				}				break;		  	default:			    clientUI.display(msg.toString());			    break;	  }  }    /**   * This method handles all data coming from the UI               *   * @param message The message from the UI.     * @throws Exception    */  public void handleMessageFromClientUI(String message)  {	  String[] args;		try		{			args = null;			if(message.contains("#")) {				args = message.split(" ");				switch(args[0]) {					case "#quit":						if(this.client.isConnected()) {							this.client.sendToServer(message);						}						this.quit();						break;					case "#logoff":						if(this.client.isConnected()) {							this.client.sendToServer(message);							this.client.closeConnection();						}						break;					case "#sethost":						if(this.client.isConnected()) {							this.clientUI.display("You are already connected !");						} else {							this.client.setHost(args[1]);						}						break;					case "#setport":						if(this.client.isConnected()) {							this.clientUI.display("You are already connected !");						} else {							this.client.setPort(Integer.parseInt(args[1]));						}						break;					case "#gethost":						this.clientUI.display(this.client.getHost());						break;					case "#getport":						this.clientUI.display(Integer.toString(this.client.getPort()));						break;					case "#login":						if(this.client.isConnected()) {							this.clientUI.display("You are already connected !");						} else {							try {								this.id = args[1];							} catch(ArrayIndexOutOfBoundsException e) {															}							this.client.openConnection();							this.client.sendToServer(message);						}						break;					default:						this.clientUI.display("Sorry, command not found !");						break;				}			} else {				if(this.client.isConnected()) {					this.client.sendToServer(message);				}			}	    }	    catch(IOException e)	    {	      clientUI.display("Could not send message to server.");	      this.quit();	    }  }    /**   * This method terminates the client.   */  public void quit()  {    try    {      this.client.closeConnection();    }    catch(IOException e) {		clientUI.display("Error when closing connection");    }    System.exit(0);  }	@Override	public void update(Observable o, Object arg) {		if(arg instanceof String) {			this.handleMessageFromServer((String)arg);		} else if (arg instanceof Exception) {				this.connectionException((Exception)arg);			}		}			}//End of ChatClient class